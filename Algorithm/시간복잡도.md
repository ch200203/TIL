## 시간복잡도

- 알고리즘의 시간 복잡도

입력의 크기에 대해 어느정도의 시간을 사용할지 근사적으로 표현한 것.

시간복잡도는 `O(···)` 로 표기하고, 입력이 n 일때 코드가 몇번 실행되는지 괄호안에 함수를 넣는다.

ex) `O(n^2)` 반복문
```java
for(int i=0; i < n; i++){
	for (int j = 0; j < n; j++) {
        // do something
    }
}
```

**O(1)**  
	- 상수 시간 알고리즘입니다. 
	- 입력의 크기에 영향 받지 않는 알고리즘 입니다.  
	- 주로 수학 공식등을 이용해 답을 바로 계산해내는 문제들의 시간복잡도입니다.  

***
 

**O(log n)**  
	- 로그 시간 알고리즘 입니다.

*** 

**O(√n)**  
	- 루트 시간 알고리즘 입니다.  
	- 가장 많이 쓰일 때는 어떤 수 n이 소수인지 판별할 때일 것입니다.  
	- 1부터 √n까지 모든 수로 나눠떨어지지 않는다면 n은 소수입니다.  
	
***

**O(n)**  
	- 선형 시간 알고리즘 입니다.
	- 문제 풀때 대부분의 풀이는 최소 이 시간복잡도를 깔고 가는데, n회의 입력/출력을 하는데 이미 O(n)의 시간이 걸리기 때문입니다.

*** 

**O(nlogn)** 
	- n개의 원소를 정렬할 때의 일반적인 시간복잡도 입니다.  
	- 또는 연산에 log n의 시간이 걸리는 자료구조를 사용 할 때에도 흔히 볼 수 있습니다.

***

**O(n^2), O(n^3)**
	- k중 반복문을 사용했을 때 시간복잡도는 일반적으로 O(n^k)입니다.  

***


**O(2n)**  
	- n개의 원소로 만들 수 있는 모든 부분집합을 탐색할 때 볼 수 있는 시간복잡도입니다.  

***

**O(n!)**  
- n개의 원소로 만들 수 있는 모든 순열을 탐색할 때 볼 수 있는 시간복잡도입니다