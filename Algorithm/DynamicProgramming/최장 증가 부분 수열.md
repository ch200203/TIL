## 최장 증가 부분 수열(LIS, Longest Increasing Subsequence)

<br>

- O(n^2)의 시간복잡도를 가지는 알고리즘과 O(NlongN)의 두가지 시간복잡도를 갖는 알고리즘이 있다.

- 부분 수열 : 주어진 수열에서 일부 원소를 뽑아서 새로 만든 수열을 **'부분수열'**
- 부분 수열의 수들이 순 증가(오름차순을 유지)하면 증가 부분 수열
- LIS는 주어진 수열의 증가 부분 수열 중 가장 긴 것을 찾는 문제

Ex)
```python
# S라는 수열이 존재 한다고 할 때
S = [4, 2, 1, 3, 5, 8, 6, 7]

# 가장 길이가 긴 수열
LIS = [2, 3, 5, 6, 7] or [1, 3, 5, 6, 7]
```


### 완전 탐색 풀이
- 입력이 배열이기 때문에 메모제이션 활용이 어려움
- 수열의 크기가 1000인 Boj 문제 11053과 같은 문제를 해결 할 수 없음.

### 동적 계획법 사용 1: O(n^2)

1) 수열의 길이와 같은 dp 배열을 선언
2) 수열을 처음 부터 끝까지 순서대로 탐색
    - dp[i]를 먼저 1로 초기화 한다.
    - dp[i]의 값이 앞선 원소들 0 ~ i-1 까지의 비해 큰 값이라면, **LIS**가 될 수 있음,  
    따라서, 앞선 원소들의 값들 중 본인의 길이(1)를 더한 값 중 가장 큰 값을 저장한다.
    
        * 최초 방문시 dp[i] = 1
        * dp[0 ~ i-1]번째 원소해 비해 현재 값이 크고 그 위치를 j라고 한다면
        * dp[i] = Math.max(dp[i], dp[j] + 1)

    
```java
class Main {
    public static void main(String[] args) {
        int[] arr = {10, 20, 10, 30, 20, 50};
        // 수열과 같은 크기의 dp 배열 선언
        int[] dp = new int[arr.length];
        // 최대 LIS의 길이 값
        int max = 1;

        for(int i = 0; i < n; i++) {
            dp[i] = 1;
            for(int j = 0; i < i; i++) {
                if(arr[i] > arr[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }

            max = Math.max(max, dp[i]);
        }
        
        System.out.println(max);
    }
}
```


### 동적 계획법 사용 2 : O(NlogN)

- 이분탐색을 이용한 방법

